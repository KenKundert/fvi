#!/usr/bin/env python
# FVI
#
# Searches through a list of files to find a string, and then sequentially opens
# each file that contains the string in vim.
#
# Copyright (C) 2013-14 Kenneth S. Kundert

# License {{{1
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, either version 3 of the License, or (at your option) any later
# version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along with
# this program.  If not, see http://www.gnu.org/licenses/.


# Imports {{{1
from __future__ import print_function, division
try:
    from textwrap import fill
    import argparse
    import re
    import os
    import sys
    from subprocess import call, Popen as popen, PIPE

    # Eliminate duplicate files {{{1
    def eliminateDuplicateFiles(files):
        seen = set()
        todo = []
        ignore = []
        for fn in files:
            nfo = os.stat(fn)
            if nfo.st_ino in seen:
                ignore.append(fn)
            else:
                seen.add(nfo.st_ino)
                todo.append(fn)
        if ignore:
            print('Ignoring duplicate files:\n    %s' %  '\n    '.join(ignore))
        return todo

# Read the command line {{{1
    prog_name = os.path.split(sys.argv[0])[1]
    parser = argparse.ArgumentParser(
        description=fill(' '.join([
            "Search for files that contain a string",
            "and then open them in vim."
        ]))
    )
    arguments = parser.add_argument_group('arguments')
    arguments.add_argument(
        'pattern', nargs=1, default='', help="search pattern")
    arguments.add_argument(
        'files', nargs='*', default='', metavar='file',
        help="a file to search")
    parser.add_argument(
        '-w', '--word', action='store_true', help="match a word")
    parser.add_argument(
        '-i', '--ignore-case', action='store_true', help="ignore case")
    parser.add_argument(
        '-m', '--magic', action='store_true',
        help="treat pattern as a vim magic or grep basic regular expression")
    parser.add_argument(
        '-v', '--very-magic', action='store_true',
        help="treat pattern as a vim very magic or grep extended regular expression")
    parser.add_argument(
        '-g', '--gvim', action='store_true',
        help="open files in gvim rather than vim")
    cmdline = parser.parse_args()

    # Initialization {{{1
    vim_flags = ['aw', 'nofen']  # enable autowrite and disable folds in vim
    grep_flags = ['--files-with-matches']
    use_grep = False
    re_flags = 0
    cmd = None

    # Process the command line {{{1
    pattern = cmdline.pattern[0]
    re_pattern = re.escape(pattern)
    if cmdline.word:
        grep_flags += ['--word-regexp']
        vim_pattern_prefix = r'\<'
        vim_pattern_suffix = r'\m\>'
        re_pattern = r'\b' + pattern + r'\b'
    else:
        vim_pattern_prefix = ''
        vim_pattern_suffix = ''
    if cmdline.ignore_case:
        grep_flags += ['--ignore-case']
        re_flags += re.IGNORECASE
        vim_pattern_prefix += r'\c'
    if cmdline.very_magic:
        use_grep = True
        grep_flags += ['--extended-regexp']
        vim_pattern_prefix += r'\v'
    elif cmdline.magic:
        use_grep = True
        grep_flags += ['--basic-regexp']
        vim_pattern_prefix += r'\m'
    else:
        vim_pattern_prefix += '\V'
    editor = 'gvim' if cmdline.gvim else 'vim'

    # Find files to edit {{{1
    if cmdline.files:
        # User has given a list of files.
        # Try to open each and eliminate if it is undesirable (is a directory,
        # is unreadable, or is a binary file).
        # Then, if doing a non-magic search, also filter out any files that do
        # not contain the search string.
        # If doing a magic search, build the command line for grep that will be
        # used to filter out files that do not contain the search pattern.
        files = []
        regex = re.compile(re_pattern, re_flags)
        for each in cmdline.files:
            try:
                with open(each) as f:
                    contents = f.read()
                    if use_grep or regex.search(contents, re_flags):
                        files += [each]
            except IOError as err:
                print('%s: %s: %s, skipping ...' % (
                    prog_name, err.filename, err.strerror
                ))
            except UnicodeDecodeError:
                print("%s: %s: is a binary file, skipping ..." % (
                    prog_name, each
                ))
        if use_grep:
            cmd = ['grep'] + grep_flags + ['--regexp', pattern] + files
    else:
        # The user gave us no files to search, so use ack to find them
        ack_flags = [
            each
            for each in grep_flags
            if each not in ['--basic-regexp', '--extended-regexp']
        ]
        if set(ack_flags) != set(grep_flags):
            print("%s: ack does not support the magic flags, ignored." % (
                prog_name
            ))
        cmd = ['ack'] + ack_flags + [pattern]

    # Run either grep to filter out any files that do not contain the search
    # pattern or ack to find any files that contain the pattern.
    if cmd:
        try:
            process = popen(cmd, stdout=PIPE)
            stdout = process.stdout.read().decode()
            status = process.wait()
            process.stdout.close()
            if status not in [0, 1]:
                sys.exit(status)
            files = stdout.split()
        except (IOError, OSError) as err:
            where = err.filename if err.filename else ' '.join(cmd)
            sys.exit('%s: %s: %s.' % (prog_name, where, err.strerror))

    # Exit if there are no files {{{1
    if not files:
        sys.exit('%s: None of the files searched contain the pattern.' % (
            prog_name,
        ))

    # Edit the files {{{1
    files = eliminateDuplicateFiles(files)
    vim_options = 'set %s' % ' '.join(vim_flags)
    next_file_map = 'map <C-N> :n +//<CR>'
    search_pattern = 'silent /%s' % (
        vim_pattern_prefix + pattern + vim_pattern_suffix
    )
    cmd = (
        [editor]
        + ['+%s' % '|'.join([vim_options, next_file_map, search_pattern])]
        + files
    )
    status = call(cmd)
    sys.exit(status)

except KeyboardInterrupt:
    sys.exit('Killed by user')

# vim: set sw=4 sts=4 et:
